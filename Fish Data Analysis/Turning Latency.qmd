---
title: "Turning Latency"
format: html
editor: visual
---

```{r}
library(tidyverse)
library(ggplot2)
library(bbmle) #For ICtab
library(car)
library(ggpubr)
library(ggdist)
library(emmeans)
library(lme4)
```

```{r}
rad2deg <- function(rad) {(rad * 180) / (pi)}
deg2rad <- function(deg) {(deg * pi) / (180)}
round_any <- function(x, accuracy, f=round){f(x/ accuracy) * accuracy}
ang_mean <- function(x){rad2deg(atan2(mean(sin(deg2rad(x))),mean(cos(deg2rad(x)))))}

fold_angle_0_360_to_0_180 <- function(x){abs(abs(x-180)-180)}

fold_angle_neg_180_180_to_neg_90_90 <- function(x){ifelse(x > 90,90-abs(90-x),ifelse(x < -90, -90+abs(-90-x), x))}

min_n <- function(x,n){sort(x)[1:n]}
max_n <- function(x,n){sort(x,decreasing = TRUE)[1:n]}

light_no_ab_color = "#d4d7dd"
light_ab_color = "#f5ba9e"
dark_no_ab_color = "#5e94d4"
sim_color = "#777777"

flow_split_still = "#F59DE2"
flow_split_flow = "#5DD492"

dark_split_light = "#5e94d4"
dark_split_dark = "#011627"

tailbeat_len = 19

allowed_flow_type = c("Still Water","Flowing Water (2 BL/s)")

dot_binwidth = 0.03

text_size = 16
```


```{r}
turning_data <- read.csv("Data/eight_fish_turning_latency.csv") %>%
                           mutate(Data_ID = paste(Year,Month,Day,Trial, sep = "_")) %>% 
                           filter(Turn_Dir != "None") %>%
                           mutate(Flow = ifelse(Flow == "0", "Still Water", "Flowing Water (2 BL/s)")) %>%
                           mutate(Ablation = ifelse(Ablation  == "N", "No Ablation", "Ablated")) %>%
                           mutate(Darkness = ifelse(Darkness == "N", "Light", "Dark")) %>%
                           mutate(Flow = factor(Flow), Ablation = factor(Ablation), Darkness = factor(Darkness)) %>%
                           mutate(Flow = fct_relevel(Flow, c("Still Water","Flowing Water (2 BL/s)"))) %>%
                           mutate(Ablation = fct_relevel(Ablation, c("No Ablation","Ablated"))) %>%
                           mutate(Darkness = fct_relevel(Darkness, c("Light","Dark"))) %>%
                           mutate(Flow_Ablation_Darkness = factor(paste(Flow,Ablation,Darkness,sep=", "))) %>%
                           mutate(Fish_Num_Ratio = Fish_Right/8) %>%
                           mutate(Fish_Ratio = paste(Fish_Left,Fish_Right,sep=":")) %>%
                           filter(Fish_Ratio %in% c("7:0","6:1","5:2","4:3","3:4","2:5","1:6","0:7")) %>%
                           mutate(Fish_Ratio = fct_relevel(Fish_Ratio,
                                                           c("7:0","6:1","5:2","4:3",
                                                             "3:4","2:5","1:6","0:7"))) %>%
                           #0 is right, so this looks weird but it's fine
                           mutate(turn_bool = ifelse(Turn_Dir == "0",1,0),
                                  Turn_Dir = ifelse(Turn_Dir == "0","right","left")) %>%
                           arrange(Year, Month, Day, Trial, Frame)

latency_df <- turning_data %>% group_by(Data_ID,Turn_Dir) %>%
                               mutate(Latency = Frame - lag(Frame),
                                      Startler_Frame = lag(Frame),
                                      Startler_Fish = lag(Fish)) %>%
                               ungroup() %>%
                               filter(!is.na(Latency))

```

#Positional Data

```{r}
comp_data <- read.csv("Data/Fish_Raw_Comp_Values_3D.csv") %>% separate(Fish, c("Fish1", "Fish2"),sep="x") %>% mutate(Data_ID = paste(Year,Month,Day,Trial, sep = "_")) %>% select(c(Data_ID, Frame_Num, Fish1, Fish2, Distance))

comp_data_switch_fish <- comp_data %>% mutate(Fish3 = Fish1) %>%
                                       mutate(Fish1 = Fish2) %>%
                                       mutate(Fish2 = Fish3) %>%
                                       select(-c(Fish3))

comp_data_two <- bind_rows(comp_data, comp_data_switch_fish)
```

Now we combine them to get position and data 

```{r}

latency_data_pos <- latency_df %>% left_join(comp_data_two, by = c("Data_ID" = "Data_ID", 
                                                                   "Startler_Frame" = "Frame_Num",
                                                                   "Startler_Fish" = "Fish1")) %>%
                                   na.omit()

```


Okay, so I want to be able to say something about how long it takes fish to respond to another fish's turn in the same direction

And I want to be able to talk about the distances between them when they turn 

Actually what I *really* want is distance vs the probability of making a matching turn
  Within... let's say 50 frames 
  
  
What I want is a data frame with 8 columns: 
Date ID, Condition, Frame Number, Fish Who Turned, Turn Direction, All Eight Other Fish, If Those Fish Turned Within X Frames, Distance

So let's start trying to build that


```{r}

max_diff = 60

#So here we try and find rows where the other fish turned within max_diff frames where Data_ID is the same as is the direction of the turn
#Also we remove rows where a fish just turned

did_match_turn <- function(all_data_df,data_id,turn_frame,main_fish,other_fish,turn_dir){
  turns_in_future <- all_data_df %>% filter(Data_ID == data_id & 
                                         Frame >= turn_frame & 
                                         Frame <= turn_frame + max_diff & 
                                         Turning_Fish == other_fish & 
                                         Turn_Dir == turn_dir)
  
  just_turned <- all_data_df %>% filter(Data_ID == data_id & 
                                         Frame <= turn_frame & 
                                         Frame >= turn_frame - max_diff & 
                                         Turning_Fish == other_fish & 
                                         Turn_Dir == turn_dir)
  
  if(length(turns_in_future$Data_ID) > 0){
    return(1)
  }
  else if(length(just_turned$Data_ID) > 0){
    return(NA)
  }
  else{
    return(0)
  }
    
}

```

Fist find out if the fish match

```{r}

all_fish <- c("individual1","individual2","individual3","individual4",
              "individual5","individual6","individual7","individual8")

base_late_data_df <- tibble(Data_ID = rep(turning_data$Data_ID, each = 8),
                         Flow = rep(turning_data$Flow, each = 8),
                         Ablation = rep(turning_data$Ablation, each = 8),
                         Darkness = rep(turning_data$Darkness, each = 8),
                         Flow_Ablation_Darkness = rep(turning_data$Flow_Ablation_Darkness, each = 8),
                         Frame = rep(turning_data$Frame, each = 8),
                         Turning_Fish = rep(turning_data$Fish, each = 8),
                         Turn_Dir = rep(turning_data$Turn_Dir, each = 8),
                         Other_Fish = rep(all_fish, length(turning_data$Fish)))

late_pairing_df <- base_late_data_df %>%
                   filter(Turning_Fish != Other_Fish) %>%
                   group_by(Data_ID,Frame,Turning_Fish,Other_Fish) %>% 
                   mutate(Also_Turned = did_match_turn(.,Data_ID,Frame,Turning_Fish,Other_Fish,Turn_Dir))

```

Now combine it 

```{r}

dist_v_late_df <- late_pairing_df %>% left_join(comp_data_two, by = c("Data_ID" = "Data_ID", 
                                                                   "Frame" = "Frame_Num",
                                                                   "Turning_Fish" = "Fish1",
                                                                   "Other_Fish" = "Fish2")) %>% 
                                         filter(!is.na(Distance) & !is.na(Also_Turned) & Distance <= 10)
                                         

```

Now graph distance vs probabilty of turning!


```{r}

ggplot(dist_v_late_df %>% filter(Flow == "Still Water"),
       aes(x = Distance, y = Also_Turned, color = interaction(Ablation,Darkness,sep=", ")))+
  geom_point() +
  geom_smooth(se = F, method="glm", method.args=list(family="binomial")) +
  scale_color_manual(values=c(light_no_ab_color, light_ab_color, dark_no_ab_color)) +
  theme_light() +
  theme(legend.position = "none")

dist_late_glmer_still <- glmer(Also_Turned ~ Distance*(Ablation+Darkness) + (1|Data_ID),
                               family ="binomial", data = dist_v_late_df %>% filter(Flow == "Still Water"))
Anova(dist_late_glmer_still)

```



```{r}


ggplot(latency_df %>% filter(Flow == "Still Water"),
       aes(x = interaction(Ablation,Darkness,sep=", "), y = Latency,
           color = interaction(Ablation,Darkness,sep=", "),
           fill = interaction(Ablation,Darkness,sep=", ")))+
  stat_dots(side = "both", binwidth = unit(dot_binwidth, "npc")) +
  geom_point(aes(y = Mean_Latency), size = 5, color = "Black") +
  geom_errorbar(aes(ymin=Mean_Latency-SD_Latency, ymax=Mean_Latency+SD_Latency), width=.2, color = "Black")+
  guides(fill = guide_legend(title = "Condition")) +
  scale_fill_manual(values=c(light_no_ab_color, light_ab_color, dark_no_ab_color)) +
  scale_color_manual(values=c(light_no_ab_color, light_ab_color, dark_no_ab_color)) +
  xlab("") +
  ylab("Latency (Frames)") +
  theme_light()+ 
  theme(legend.position = "none") +
  theme(axis.text.x = element_text(size = text_size),
        axis.text.y = element_text(size = text_size),
        axis.title.y = element_text(size = text_size))+
  scale_x_discrete(labels=function(x){sub(",\\s", "\n", x)})


ggplot(latency_data_pos %>% filter(Flow == "Still Water"),
       aes(x = Distance, y = Latency, color = interaction(Ablation,Darkness,sep=", "))) +
  geom_point()+
  scale_color_manual(values=c(light_no_ab_color, light_ab_color, dark_no_ab_color)) +
  theme_light()+ 
  theme(legend.position = "none") +
  theme(axis.text.x = element_text(size = text_size),
        axis.text.y = element_text(size = text_size),
        axis.title.y = element_text(size = text_size))
  

latency_model <- lmer(Latency ~ Distance*(Ablation + Darkness) + (1|Data_ID), data = latency_data_pos)
model_sum <- summary(latency_model)

```

